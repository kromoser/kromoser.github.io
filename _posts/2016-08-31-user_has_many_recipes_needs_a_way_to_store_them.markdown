---
layout: post
title:  "User has_many recipes, needs a way to store them"
date:   2016-08-31 22:47:38 +0000
---


I recently started building my first Sinatra application from scratch, an organizer to collect and store recipes from around the web. Rather than display a recipe's preparation instructions and and exhaustive list of ingredients, it’s designed to simply organize recipes by key ingredient and category, and then provide a link to the original recipe. Many of the recipes I use are from around the web, and I often like to re-read the accompanying notes as I prepare the dish, so simply copying the recipe wasn’t quite what I was after. I simply wanted a way to keep my many recipe links tidy and sortable.

I’m about half way finished with the app, but very quickly I realized the relationships between my models were the key to it being a useful application. Sure, I could have built an app with 2 models, Users and Recipes. A user has many recipes, and a recipe belongs to a user. But the whole point of the app is to make things more organized, not just provide a messy list of recipes. I have a whole bag of tomatoes from the farmer’s market; I want to know all the tomato dishes I can make. So I added two more models, Ingredients and Types (shown to the user as recipe categories, like “dinner” or “comfort food”). A user has many recipes. A recipe has many ingredients, and a recipe has many categories. An ingredient has many recipes, though, and so does a category. I added these relationships and their necessary join tables to my database.

This is the general logic I’m working with, and it’s working well, and it’s essential to get the relationships down and working before moving onto coding the routes and views, but I’m realizing that no matter how robust the relationships between models are, without a good sense of the way the actual human user will interact with the app, the models are pretty useless. Obviously there are issues like protecting views from users that aren’t logged in, but there are other concerns, like building a form to create a recipe where you can assign it one ingredient, or two, or none at all, or choose 10 pre-existing ingredients. 

And how should you display those 10 ingredients? If it becomes such a long list that it’s a pain to scroll and sort through, maybe it says something about the logic behind the form rather than the view itself. Maybe not every ingredient should be listed, only the most common, or the first 5, or the last 5? Normally we think about the controller informing the view, but the view can also inform the controller. After all, it’s the view that the user has to *use* in order to save or see or edit a recipe.

So that’s what I’m thinking about as I finish my app. Questions like, *How will this page look when there are 100 recipes stored in the database?* *How efficient would a method be that finds all recipes that belong to a particular ingredient, but only if those recipes belong to the current user, if the database has a 1,000 recipes? Is there a better way to query the database?* Ultimately the things we build are for users, so the user experience shouldn’t be the sole purview of the designer. It’s a concern I’m trying to be aware of throughout the programming process, from building the models, (*I’ll want to associate Recipe A with Ingredient B*),  to programming the controller (*How can this logic return the best information most efficiently?*), and ultimately rendering the view (*Will this page be a pleasure to look at and use?*). All of these pieces are needed to make an app that works well, looks great, and feels like a million bucks.
